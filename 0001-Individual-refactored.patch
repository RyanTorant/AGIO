From 3bc2a0326afeea05259a3572b6095655502f192e Mon Sep 17 00:00:00 2001
From: Nicolas Ottonello <nicolas.ottonello96@gmail.com>
Date: Tue, 18 Dec 2018 08:24:53 -0300
Subject: [PATCH 1/1] Individual refactored

---
 src/Evolution/Individual.cpp                  | 463 ++----------------
 src/Evolution/Individual.h                    |   2 +-
 src/Evolution/Population.cpp                  |  60 ++-
 src/Evolution/Population.h                    |   2 +
 src/Serialization/SIndividual.cpp             |  11 +
 src/Tests/PreyPredator/Config.cfg             |  10 +-
 .../PreyPredator/PublicInterfaceImpl.cpp      |  18 +-
 7 files changed, 96 insertions(+), 470 deletions(-)

diff --git a/src/Evolution/Individual.cpp b/src/Evolution/Individual.cpp
index 2c5fe22..19ad388 100644
--- a/src/Evolution/Individual.cpp
+++ b/src/Evolution/Individual.cpp
@@ -30,68 +30,25 @@ Individual::Individual() noexcept : RNG(chrono::high_resolution_clock::now().tim
 	NeedGenomeDeletion = false;
 }
 
-#if 0
-void Individual::Spawn(int ID)
+Individual::Individual(MorphologyTag tag, NEAT::Genome * in_genome) : Individual()
 {
-    assert(Interface->GetActionRegistry().size() > 0);
-    assert(Interface->GetSensorRegistry().size() > 0);
+    Morphology = move(tag);
+    Genome = in_genome->duplicate(GlobalID);
+    Brain = Genome->genesis(Genome->genome_id);
+    Parameters = Genome->MorphParams;
 
-    // TODO : Find if there's a way to avoid the memory allocations
     unordered_set<int> actions_set;
     unordered_set<int> sensors_set;
 
-    // Construct the components list
-    for (auto[gidx, group] : enumerate(Interface->GetComponentRegistry()))
-    {
-        // TODO : Profile what's the best way to do this
-        int components_count = uniform_int_distribution<int>(group.MinCardinality, group.MaxCardinality)(RNG);
-
-        vector<int> index_vec(group.Components.size());
-        for (auto[idx, v] : enumerate(index_vec)) v = idx;
-
-        shuffle(index_vec.begin(), index_vec.end(), RNG);
-
-        for (int i = 0; i < components_count; i++)
-        {
-            Components.push_back({(int) gidx, index_vec[i]});
-
-            const auto &component = group.Components[index_vec[i]];
-
-            actions_set.insert(component.Actions.begin(), component.Actions.end());
-            sensors_set.insert(component.Sensors.begin(), component.Sensors.end());
-        }
-    }
-
-    // Construct the parameters list
-    // Initially, spawn the parameters in the middle, with the same historical marker
-    // after spawning, shift them a bit randomly.
-    // This allows to cross parameters that are similar, by keeping track of the historical markers
-    // A mutation can change the parameter, and it'll get a new historical marker
-    for (auto[pidx, param] : enumerate(Interface->GetParameterDefRegistry()))
+    for (auto[gidx, cidx] : Morphology)
     {
-        // If the parameter is not required, select it randomly, 50/50 chance
-        // TODO : Maybe make the selection probability a parameter? Does it makes sense?
-        if (param.IsRequired || uniform_int_distribution<int>(0, 1)(RNG))
-        {
-            Parameter p{};
-            p.ID = pidx;
-            p.Value = 0.5f * (param.Min + param.Max);
-            p.HistoricalMarker = Parameter::CurrentMarkerID;
-			p.Min = param.Min;
-			p.Max = param.Max;
-
-            // Small shift
-            float shift = normal_distribution<float>(0, Settings::ParameterMutationSpread)(RNG);
-            p.Value +=  shift * abs(param.Max - param.Min);
-
-            // Clamp values
-            p.Value = clamp(p.Value, param.Min, param.Max);
+        const auto &component = Interface->GetComponentRegistry()[gidx].Components[cidx];
 
-            Parameters[param.UserID] = p;
-        }
+        actions_set.insert(component.Actions.begin(), component.Actions.end());
+        sensors_set.insert(component.Sensors.begin(), component.Sensors.end());
     }
 
-    // Convert the action and sensors set to vectors
+    // Compute action and sensors vectors
     Actions.resize(actions_set.size());
     for (auto[idx, action] : enumerate(actions_set))
         Actions[idx] = action;
@@ -106,45 +63,25 @@ void Individual::Spawn(int ID)
     sort(Actions.begin(), Actions.end());
     sort(Sensors.begin(), Sensors.end());
 
-    SensorsValues.resize(Sensors.size());
     ActivationsBuffer.resize(Actions.size());
+    SensorsValues.resize(Sensors.size());
 
-    // Create base genome and network
-    Genome = new NEAT::Genome(Sensors.size(), Actions.size(), 0, 0);
-
-    // Randomize weights and traits
-    // The settings are taken from NEAT/src/population.cpp, line 280
-    Genome->mutate_link_weights(1, 1, NEAT::COLDGAUSSIAN);
-    Genome->randomize_traits();
-
-    // Construct network from genome
-    Brain = Genome->genesis(Genome->genome_id);
+    NeedGenomeDeletion = true;
 
-    // Create a new state
     State = Interface->MakeState(this);
+}
 
-    // Fill bitfields
-    Morphology.ActionsBitfield.resize((Interface->GetActionRegistry().size() - 1) / 32 + 1);
-    fill(Morphology.ActionsBitfield.begin(), Morphology.ActionsBitfield.end(), 0);
-    for (auto action : Actions)
-        // I'm hoping that the compiler is smart enough to change the / and % to ands and shift
-        Morphology.ActionsBitfield[action / 32] |= 1 << (action % 32);
-
-    Morphology.SensorsBitfield.resize((Interface->GetSensorRegistry().size() - 1) / 32 + 1);
-    fill(Morphology.SensorsBitfield.begin(), Morphology.SensorsBitfield.end(), 0);
-    for (auto sensor : Sensors)
-        // I'm hoping that the compiler is smart enough to change the / and % to ands and shift
-        Morphology.SensorsBitfield[sensor / 32] |= 1 << (sensor % 32);
+void Individual::Reset()
+{
+    Interface->ResetState(State);
+    if (Brain) Brain->flush();
+    Fitness = 0;
+}
 
-    Morphology.Parameters = Parameters;
-    Morphology.NumberOfActions = Actions.size();
-    Morphology.NumberOfSensors = Sensors.size();
-	Morphology.Genes.reset(Genome->duplicate(Genome->genome_id));
-    /*Morphology.GenesIDs.resize(Genome->genes.size());
-    for (auto[gene_id, gene] : zip(Morphology.GenesIDs, Genome->genes))
-        gene_id = gene->innovation_num;*/
+int Individual::DecideAction(const std::unordered_map<int, float> &SensorsValues)
+{
+    throw "This method should not be used";
 }
-#endif
 
 void Individual::DecideAndExecute(void *World, const vector<BaseIndividual*> &Individuals)
 {
@@ -182,274 +119,22 @@ void Individual::DecideAndExecute(void *World, const vector<BaseIndividual*> &In
         action = action_dist(RNG);
     }
 
+	// test select action with higher probability
+	float action_score = 0;
+	for (auto[action_idx, activation] : enumerate(ActivationsBuffer))
+	{
+		if (activation > action_score)
+		{
+			action_score = activation;
+			action = action_idx;
+		}
+	}
+
     // Finally execute the action
     Interface->GetActionRegistry()[Actions[action]].Execute(State, Individuals, this, World);
 }
 
-void Individual::Reset()
-{
-    Interface->ResetState(State);
-    if (Brain) Brain->flush();
-    Fitness = 0;
-}
-#if 0
-Individual::Individual(const Individual &Parent, Individual::Make) : Individual()
-{
-    OriginalID = Parent.OriginalID;
-    LastDominationCount = Parent.LastDominationCount;
-    Fitness = Parent.Fitness;
-    LastNoveltyMetric = Parent.LastNoveltyMetric;
-
-    Actions = Parent.Actions;
-    Sensors = Parent.Sensors;
-    ActivationsBuffer.resize(Parent.Actions.size());
-    SensorsValues.resize(Parent.Sensors.size());
-    Components = Parent.Components;
-    Parameters = Parent.Parameters;
-    Morphology = Parent.Morphology;
-	
-    State = Interface->DuplicateState(Parent.State);
-
-    Genome = Parent.Genome->duplicate(GlobalID);
-    Brain = Genome->genesis(Genome->genome_id);
-
-    AccumulatedFitness = Parent.AccumulatedFitness;
-    //AccumulatedNovelty = Parent.AccumulatedNovelty;
-    //EvaluationsCount = Parent.EvaluationsCount;
-
-	SpeciesPtr = Parent.SpeciesPtr;
-};
-
-void Individual::Mutate(Population *population, int generation)
-{
-    // If there was any mutation at all, and this individual was a clone of a previous one, it stops beign a copy
-    // so the original ID needs to change
-    bool any_mutation = false;
-
-    auto randfloat = [this]()
-    {
-        return uniform_real_distribution<float>()(RNG);
-    };
-
-    // Mutate components
-    if (randfloat() < Settings::ComponentMutationProb)
-    {
-        // Choose at random one group to mutate a component
-        int group_idx = uniform_int_distribution<int>(0, Interface->GetComponentRegistry().size() - 1)(RNG);
-        const ComponentGroup &group = Interface->GetComponentRegistry()[group_idx];
-
-        // The component to be mutated
-        int component_idx = uniform_int_distribution<int>(0, group.Components.size() - 1)(RNG);
-
-        int group_count = 0;
-        for (auto &c : Components)
-            if (c.GroupID == group_idx)
-                group_count++;
-
-        if (randfloat() < Settings::ComponentAddProbability && group.MaxCardinality < group_count)
-        {
-            // If the individual hasn't the chosen component yet, add it
-            bool found = false;
-            for (auto &c : Components)
-            {
-                if (c.GroupID == group_idx && c.ComponentID == component_idx)
-                {
-                    found = true;
-                    break;
-                }
-            }
-
-            if (!found)
-            {
-                Components.push_back({group_idx, component_idx});
-                any_mutation = true;
-            }
-        } else if (randfloat() < Settings::ComponentRemoveProbability && group.MinCardinality < group_count)
-        {
-            for (auto it = Components.begin(); it != Components.end(); it++)
-            {
-                if (it->GroupID == group_idx && it->ComponentID == component_idx)
-                {
-                    Components.erase(it);
-                    any_mutation = true;
-                    break;
-                }
-            }
-        } else if (randfloat() < Settings::ComponentChangeProbability)
-        {
-            // If the individual has the chosen component, swap it for one at random of the same group
-            for (auto it = Components.begin(); it != Components.end(); it++)
-            {
-                if (it->GroupID == group_idx && it->ComponentID == component_idx)
-                {
-                    int replacement_idx = uniform_int_distribution<int>(0, group.Components.size() - 1)(RNG);
-                    *it = {group_idx, replacement_idx};
-                    any_mutation = true;
-                    break;
-                }
-            }
-
-        }
-        if (any_mutation)
-        {
-            unordered_set<int> actions_set;
-            unordered_set<int> sensors_set;
-
-            for (const auto &compRef : Components)
-            {
-                const ComponentGroup &group = Interface->GetComponentRegistry()[compRef.GroupID];
-                const auto &component = group.Components[compRef.ComponentID];
-                actions_set.insert(component.Actions.begin(), component.Actions.end());
-                sensors_set.insert(component.Sensors.begin(), component.Sensors.end());
-            }
-
-            std::vector<int> newActions(actions_set.size());
-            std::vector<int> newSensors(sensors_set.size());
-
-            for (auto[idx, action] : enumerate(actions_set))
-                newActions[idx] = action;
-
-            for (auto[idx, sensor] : enumerate(sensors_set))
-                newSensors[idx] = sensor;
 
-            sort(newActions.begin(), newActions.end());
-            sort(newSensors.begin(), newSensors.end());
-
-            if (newActions != Actions || newSensors != Sensors)
-            {
-                Actions = newActions;
-                Sensors = newSensors;
-
-                SensorsValues.resize(Sensors.size());
-                ActivationsBuffer.resize(Actions.size());
-
-                // Create base genome and network
-                Genome = new NEAT::Genome(Sensors.size(), Actions.size(), 0, 0);
-
-                // Randomize weights and traits
-                // The settings are taken from NEAT/src/population.cpp, line 280
-                Genome->mutate_link_weights(1, 1, NEAT::COLDGAUSSIAN);
-                Genome->randomize_traits();
-
-                // Construct network from genome
-                Brain = Genome->genesis(Genome->genome_id);
-
-                // Fill bitfields
-                Morphology.ActionsBitfield.resize((Interface->GetActionRegistry().size() - 1) / 32 + 1);
-                fill(Morphology.ActionsBitfield.begin(), Morphology.ActionsBitfield.end(), 0);
-                for (auto action : Actions)
-                    // I'm hoping that the compiler is smart enough to change the / and % to ands and shift
-                    Morphology.ActionsBitfield[action / 32] |= 1 << (action % 32);
-
-                Morphology.SensorsBitfield.resize((Interface->GetSensorRegistry().size() - 1) / 32 + 1);
-                fill(Morphology.SensorsBitfield.begin(), Morphology.SensorsBitfield.end(), 0);
-                for (auto sensor : Sensors)
-                    // I'm hoping that the compiler is smart enough to change the / and % to ands and shift
-                    Morphology.SensorsBitfield[sensor / 32] |= 1 << (sensor % 32);
-
-                Morphology.Parameters = Parameters;
-                Morphology.NumberOfActions = Actions.size();
-                Morphology.NumberOfSensors = Sensors.size();
-				Morphology.Genes.reset(Genome->duplicate(Genome->genome_id));
-                /*Morphology.GenesIDs.resize(Genome->genes.size());
-                for (auto[gene_id, gene] : zip(Morphology.GenesIDs, Genome->genes))
-                    gene_id = gene->innovation_num;*/
-            }
-        }
-    } else
-    {
-        // Only mutate network and parameters if the components were not mutated
-        // Mutate NEAT network
-        if (randfloat() < Settings::NEAT::MutateAddNodeProb)
-        {
-            Genome->mutate_add_node(SpeciesPtr->innovations, population->cur_node_id, population->cur_innov_num);
-            any_mutation = true;
-        } else if (randfloat() < Settings::NEAT::MutateAddLinkProb)
-        {
-            // TODO: Find out why genesis is done in neat code (species.cpp 585)
-            NEAT::Network *net_analogue = Genome->genesis(generation);
-            Genome->mutate_add_link(SpeciesPtr->innovations, population->cur_innov_num, NEAT::newlink_tries);
-            delete net_analogue;
-            any_mutation = true;
-        } else
-        {
-            // NOTE:  A link CANNOT be added directly after a node was added because the phenotype
-            //        will not be appropriately altered to reflect the change
-
-            //If we didn't do a structural mutation, we do the other kinds
-            if (randfloat() < Settings::NEAT::MutateRandomTraitProb)
-            {
-                Genome->mutate_random_trait();
-                any_mutation = true;
-            }
-
-            if (randfloat() < Settings::NEAT::MutateLinkTraitProb)
-            {
-                Genome->mutate_link_trait(1);
-                any_mutation = true;
-            }
-            if (randfloat() < Settings::NEAT::MutateNodeTraitProb)
-            {
-                Genome->mutate_node_trait(1);
-                any_mutation = true;
-            }
-            if (randfloat() < Settings::NEAT::MutateLinkWeightsProb)
-            {
-                Genome->mutate_link_weights(Settings::NEAT::WeightMutPower, 1.0, NEAT::mutator::GAUSSIAN);
-                any_mutation = true;
-            }
-            if (randfloat() < Settings::NEAT::MutateToggleEnableProb)
-            {
-
-                Genome->mutate_toggle_enable(1);
-                any_mutation = true;
-            }
-
-            if (randfloat() < Settings::NEAT::MutateGeneReenableProb)
-            {
-                Genome->mutate_gene_reenable();
-                any_mutation = true;
-            }
-
-        }
-
-        // Mutate all parameters with certain probability
-        for (auto &[idx, param] : Parameters)
-        {
-            if (uniform_real_distribution<float>()(RNG) <= Settings::ParameterMutationProb)
-            {
-				any_mutation = true;
-
-                if (uniform_real_distribution<float>()(RNG) <= Settings::ParameterDestructiveMutationProb)
-                {
-                    uniform_real_distribution<float> distribution(param.Min, param.Max);
-                    param.Value = distribution(RNG);
-                    param.HistoricalMarker = Parameter::CurrentMarkerID.fetch_add(1);// Create a new historical marker
-                } 
-				else
-                {
-					float shift = normal_distribution<float>(0, Settings::ParameterMutationSpread)(RNG);
-					param.Value += shift * abs(param.Max - param.Min);
-
-					// Clamp values
-					param.Value = clamp(param.Value, param.Min, param.Max);
-                }
-            }
-        }
-    }
-
-    // If it was a clone and it mutated, it's no longer a clone
-	if (any_mutation && GlobalID != OriginalID)
-	{
-		OriginalID = GlobalID;
-		// Also reset the accumulators, as they are no longer valid
-		AccumulatedFitness = 0;
-		//AccumulatedNovelty = 0;
-		//EvaluationsCount = 0;
-	}
-        
-}
-#endif
 Individual::Individual(Individual &&other) noexcept
 {
     OriginalID = other.OriginalID;
@@ -472,48 +157,9 @@ Individual::Individual(Individual &&other) noexcept
     other.State = nullptr;
 }
 
-Individual::Individual(MorphologyTag Tag,NEAT::Genome * InGenome) : Individual()
-{
-	Morphology = move(Tag);
-	Genome = InGenome->duplicate(GlobalID);
-	Brain = Genome->genesis(Genome->genome_id);
-	Parameters = Genome->MorphParams;
-
-	unordered_set<int> actions_set;
-	unordered_set<int> sensors_set;
-
-	for (auto[gidx, cidx] : Morphology)
-	{
-		const auto &component = Interface->GetComponentRegistry()[gidx].Components[cidx];
-
-		actions_set.insert(component.Actions.begin(), component.Actions.end());
-		sensors_set.insert(component.Sensors.begin(), component.Sensors.end());
-	}
-
-	// Compute action and sensors vectors
-	Actions.resize(actions_set.size());
-	for (auto[idx, action] : enumerate(actions_set))
-		Actions[idx] = action;
-
-	Sensors.resize(sensors_set.size());
-	for (auto[idx, sensor] : enumerate(sensors_set))
-		Sensors[idx] = sensor;
-
-	// Sort the actions and the sensors vectors
-	// This is important! Otherwise mating between individuals is meaningless, because the order is arbitrary
-	//  and the same input could mean different things for two individuals of the same species
-	sort(Actions.begin(), Actions.end());
-	sort(Sensors.begin(), Sensors.end());
-
-	ActivationsBuffer.resize(Actions.size());
-	NeedGenomeDeletion = true;
-
-	State = Interface->MakeState(this);
-}
-
 Individual::~Individual()
 {
-    if(Brain) delete Brain;
+    delete Brain;
 
 	// Don't delete the genome here
 	// It's the same pointer that's stored on the (NEAT) population, so it'll be deleted when the population is deleted
@@ -522,43 +168,4 @@ Individual::~Individual()
 	if(NeedGenomeDeletion && Genome) delete Genome;
 
     if (State) Interface->DestroyState(State);
-}
-
-int Individual::DecideAction(const std::unordered_map<int, float>& ValuesMap)
-{
-	if (!UseNetwork)
-	{
-		uniform_int_distribution<int> action_dist(0, Actions.size() - 1);
-		return Actions[action_dist(RNG)];
-	}
-
-	// Load sensors
-	for (auto[value, idx] : zip(SensorsValues, Sensors))
-		value = ValuesMap.find(idx)->second; // TODO : Check if the value exists first
-
-	// Send sensors to brain and activate
-	Brain->load_sensors(SensorsValues);
-	bool sucess = Brain->activate(); // TODO : Handle failure
-
-	// Select action based on activations
-	float act_sum = 0;
-	for (auto[idx, v] : enumerate(Brain->outputs))
-		act_sum += ActivationsBuffer[idx] = v->activation; // The activation function is in [0, 1], check line 461 of neat.cpp
-
-	int action;
-	if (act_sum > 1e-6)
-	{
-		discrete_distribution<int> action_dist(begin(ActivationsBuffer), end(ActivationsBuffer));
-		action = action_dist(RNG);
-	}
-	else
-	{
-		// Can't decide on an action because all activations are 0
-		// Select one action at random
-		uniform_int_distribution<int> action_dist(0, Actions.size() - 1);
-		action = action_dist(RNG);
-	}
-
-	// Return final action id
-	return Actions[action];
-}
+}
\ No newline at end of file
diff --git a/src/Evolution/Individual.h b/src/Evolution/Individual.h
index 6b9cbb9..468fd6a 100644
--- a/src/Evolution/Individual.h
+++ b/src/Evolution/Individual.h
@@ -37,7 +37,7 @@ namespace agio
 
 		// Constructor that makes an individual from a NEAT genome and a morphology tag
 		// NOTE : It duplicates the genome!
-		Individual(MorphologyTag Morphology,NEAT::Genome * Genome);
+		Individual(MorphologyTag tag,NEAT::Genome * in_genome);
 
 		// Does 4 steps
 		//    1) Load the sensors from the world
diff --git a/src/Evolution/Population.cpp b/src/Evolution/Population.cpp
index d0cb6e3..8be39f1 100644
--- a/src/Evolution/Population.cpp
+++ b/src/Evolution/Population.cpp
@@ -48,6 +48,38 @@ MorphologyTag Population::MakeRandomMorphology()
 	return tag;
 }
 
+void Population::createSpecies(int pop_size)
+{
+    // The loop is finished when no new species can be found
+    //   or when the pop size / (species count + 1)  < Min Species Individuals
+    bool finished = false;
+    while (!finished)
+    {
+        // Check if we have enough species
+        int species_needed = ceil(pop_size / float(Settings::MinIndividualsPerSpecies));
+        if (species_needed < SpeciesMap.size())
+            break;
+
+        // Create a new random morphology
+        auto tag = MakeRandomMorphology();
+        int tries = 0;
+        while (SpeciesMap.find(tag) != SpeciesMap.end())
+        {
+            tries++;
+            if (tries > Settings::MorphologyTries)
+            {
+                finished = true;
+                break;
+            }
+
+            tag = MakeRandomMorphology();
+        }
+
+        // Now that a species has been found, insert it into the map
+        SpeciesMap[tag] = Species();
+    }
+}
+
 void Population::Spawn(int SizeMult,int SimSize)
 {
 	int pop_size = SizeMult * SimSize;
@@ -55,33 +87,7 @@ void Population::Spawn(int SizeMult,int SimSize)
 	SimulationSize = SimSize;
 	Individuals.reserve(pop_size);
 
-	// The loop is finished when no new species can be found
-	//   or when the pop size / (species count + 1)  < Min Species Individuals
-	bool finished = false;
-	while (!finished)
-	{
-		// Check if we have enough species
-		if (float(pop_size) / float(SpeciesMap.size() + 1) <= Settings::MinIndividualsPerSpecies)
-			break;
-
-		// Create a new random morphology
-		auto tag = MakeRandomMorphology();
-		int tries = 0;
-		while (SpeciesMap.find(tag) != SpeciesMap.end())
-		{
-			tries++;
-			if (tries > Settings::MorphologyTries)
-			{
-				finished = true;
-				break;
-			}
-
-			tag = MakeRandomMorphology();
-		}
-
-		// Now that a species has been found, insert it into the map
-		SpeciesMap[tag] = Species();
-	}
+	createSpecies(pop_size);
 
 	// Now assign individuals to the species and create NEAT populations
 	int individuals_per_species = pop_size / SpeciesMap.size(); // int divide
diff --git a/src/Evolution/Population.h b/src/Evolution/Population.h
index 5a49156..f73f663 100644
--- a/src/Evolution/Population.h
+++ b/src/Evolution/Population.h
@@ -126,5 +126,7 @@ namespace agio
 
 		// Creates a random morphology
 		MorphologyTag MakeRandomMorphology();
+
+		void createSpecies(int pop_size);
 	};
 }
\ No newline at end of file
diff --git a/src/Serialization/SIndividual.cpp b/src/Serialization/SIndividual.cpp
index 07343a6..9a297d7 100644
--- a/src/Serialization/SIndividual.cpp
+++ b/src/Serialization/SIndividual.cpp
@@ -144,6 +144,17 @@ void SIndividual::DecideAndExecute(void *World, const std::vector<BaseIndividual
         action = action_dist(RNG);
     }
 
+    // test select action with higher probability
+    float action_score = 0;
+    for (auto[action_idx, activation] : enumerate(ActivationsBuffer))
+    {
+        if (activation > action_score)
+        {
+            action_score = activation;
+            action = action_idx;
+        }
+    }
+
     // Return final action id
     // Finally execute the action
     Interface->GetActionRegistry()[Actions[action]].Execute(State, Individuals, this, World);
diff --git a/src/Tests/PreyPredator/Config.cfg b/src/Tests/PreyPredator/Config.cfg
index 9f8f66d..7cacde3 100644
--- a/src/Tests/PreyPredator/Config.cfg
+++ b/src/Tests/PreyPredator/Config.cfg
@@ -4,12 +4,12 @@ FoodScoreGain = 20
 KillScoreGain = 30
 DeathPenalty = 0 # 400;
 #FoodCellCount = WorldSizeX * WorldSizeY*0.05;
-FoodProportion = 0.05
-MaxSimulationSteps = 50;
-SimulationSize = 10 # Population is simulated in batches
-PopSizeMultiplier = 30 # Population size is a multiple of the simulation size
+FoodProportion = 0.01
+MaxSimulationSteps = 300;
+SimulationSize = 1 # Population is simulated in batches
+PopSizeMultiplier = 200 # Population size is a multiple of the simulation size
 #PopulationSize = PopSizeMultiplier * SimulationSize;
-GenerationsCount = 150
+GenerationsCount = 200
 LifeLostPerTurn = 5
 BorderPenalty = 0 # 80 penalty when trying to go out of bounds
 WastedActionPenalty = 0 # 5 penalty when doing an action that has no valid target (like eating and there's no food close)
diff --git a/src/Tests/PreyPredator/PublicInterfaceImpl.cpp b/src/Tests/PreyPredator/PublicInterfaceImpl.cpp
index d03e245..b3c60a1 100644
--- a/src/Tests/PreyPredator/PublicInterfaceImpl.cpp
+++ b/src/Tests/PreyPredator/PublicInterfaceImpl.cpp
@@ -298,15 +298,15 @@ void PublicInterfaceImpl::Init()
                                              (int)SensorsIDs::NearestFoodAngle,
                                              (int)SensorsIDs::NearestFoodDistance,
                                      }
-                             },
-                             // Carnivore
-                             {
-                                     {(int)ActionsIDs::KillAndEat},
-                                     {
-                                             (int)SensorsIDs::NearestCompetidorAngle,
-                                             (int)SensorsIDs::NearestCompetidorDistance,
-                                     }
-                             }
+                             }//,
+//                             // Carnivore
+//                             {
+//                                     {(int)ActionsIDs::KillAndEat},
+//                                     {
+//                                             (int)SensorsIDs::NearestCompetidorAngle,
+//                                             (int)SensorsIDs::NearestCompetidorDistance,
+//                                     }
+//                             }
                      }
              });
 
-- 
2.17.1 (Apple Git-112)

